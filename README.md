
## 자바 언어의 장단점 및 특징

< 장점 >

1. 운영체제에 독립적이다(운영체제로 부터 메모리를 할당받는 JVM위에서 동작한다)
2. 객체지향적 언어이다(유지 및 보수에 장점이 있다).
3. 자동으로 메모리 관리를 해준다(JVM GC의 장점이자 단점).
4. 동적로딩을 지원한다.
=> 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에만 클래스를
동적으로 로딩해서 생성을 한다( = 런타임에 객체를 로딩 = 런타임에 인스턴스 생성). 또한 유지보수시 해당 클래스만 수정하면 되기 때문에(결합도가 낮을경우 = 객체 지향의 원칙을 지킨경우) 전체 애플리케이션을 다시 컴파일할 필요가 없다. 따라서 유지보수가 빠르다(객체 지향 프로그래밍의 장점).
5. 무료 라이브러리가 많다.
 
< 단점 >

1. 타언어에 비해서 비교적 실행시간이 느리다.
2. 운영체제 뿐만 아니라 JVM에 대한 이해까지 필요하다.

< VS C언어 >
1. 사실 자바는 c와같은 정적언어이다.
2. c에 비해 자바가 메모리 낭비가 더 심함
---------------------------------------------------
## 컬렉션이란 ?

Collection이라는 것은 데이터의 연속된 집합, 그룹을 의미하고 Colleciton Framework는 여러
데이터들을 저장할 수 있는 자료구조를 클래스로 정의 해놓은 인터페이스 프레임워크를 의미합니다.
일단 Collection 인터페이스는 에는 Set, Map, List 인터페이스가 존재합니다.
그리고 무엇보다도 배열과의 차이점은 배열의 경우 정적으로 메모리를 할당하는 대신에 컬렉션의 경우
동적으로 메모리를 할당하게 됩니다. 리스트의 경우에는 메모리에 분산이 되어서 저장이됩니다 반대로
배열은 메모리에 연속적으로 저장이 됩니다 하지만 둘다 메모리는 힙영역에 저장이 된다.

1. Set
HashSet의 경우에는 저장순서를 예측할수없지만, TreeSet의 경우에는 정렬된 위치에 데이터를
저장합니다.
HashSet의 경우 해쉬함수를 이용해서 데이터를 참조하지만, TreeSet의경우에는 이진탐색을 통해서
데이터를 조회하게됩니다. 해싱이 이진탐색보다는 빠릅니다. TreeSet의 경우에는 이진탐색을 이용했기
때문에 정렬이 가능합니다.

HashSet값을 비교할때는 hashcode()를 통해 비교하며 두값의 hashcode()값이 equals == true 라면 같은값!

2. Map
Map 인터페이스의 경우에는 Key와 value로 구성이 되어있는 컬렉션인데요, 키의 중복은 허용되지만
value의 중복은 허용되지 않습니다

HashTable vs HashMap
1. HashTable의 경우 Null을 허용하지 않고, HashMap의 경우 Null을 허용한다 ! 
2. HashTable의 경우에는 동기화를 허용하며, HashMap은 안된다.
3. HashMap은 HashTable에 비해서 보조해시를 사용하기 때문에 해시충돌이 덜 발생한다. 비교적
저장을하는즉시 key값이나 value값에 따라서 정렬된 위치에 저장이된다

hash or tree
일반적으로 순서에 의존하지않고 value값을 조회하고 싶으면 hashSet을 사용하는게 맞습니다. 다만
iterator하게 value 값 전체를 처리해야한다면, treeSet을 사용하는게 좋습니다. 이는 O(logn)의 시간이
걸리게 됩니다.( 추가/ 제거 또한 마찬가지 O(logN)

List 인터페이스의 경우에는 앞서말씀드린 Set과 Map인터페이스와 달리 순서가 존재하며 데이터의
중복을 허용하는 컬렉션입니다.

ArrayList는 객체 자체를 저장하는것이아니고, 객체의 주소를 저장하는 것이다

LinkedList는 ArrayList와는 달리 인접된 객체를 링크해서 체인처럼 관리하기 때문에 조회를 하는데에는 시간이
오래걸립니다
다만 동일한 객체를 저장하게 되면 인덱스에는 객체가 저장되는게 아니고 객체의 주소가 저장이 되기때문에
동일한 주소가 저장이된다(ex) nonclustered index).

vector와 ArrayList의 차이점에 대해서는 Tread-Safe 의 유무인데 벡터의 경우에는 멀티스레드가
동시에 벡터에 접근을 할 수 없기때문에 안전하게 객체를 추가/ 수정이 가능하나, 동기화처리(Synchronized)를 하기 때문에
성능이 좋지는 않습니다.
=> vector 보다 copyonwriteArrayList()를 사용하는 게 좋다 ( 쓰기에만 lock()이 걸리고 읽기 동작은
lock 없이 사용이 가능하다 )

TMI) vertor를 상속받는 stack의 경우 FILO형식을 따르며 push를 통해서 위쪽에 데이터값을 쌓아올리는 방식인대, vector의 add public 메서드를 상속받아서 형식을 헤치게됌,
상속의 문제점을 보여주는 단편적인 예시이며 상속과 조합을 적절히 사용해야함을 알려줌!

LinkedList의 경우에는 ArrayList와는 달리, 값을 조회하는데는 최악의로는 O(N)의 시간이 발생하지만,
추가/삭제를 하는데에는 상수값의 시간으로 작업이 가능합니다. 반대로 ArrayList의 경우에는 데이터를
추가/삭제하는데 데이터의 위치를 전부 뒤로 당기거나 앞으로 밀리는 경우가 있기 때문에 최악의 경우
O(N) 시간이 발생하게 됩니다.

3. List와 Array의 차이점
배열은 메모리에 연속적으로 저장이되고, 리스트는 메모리에 연속적이 아니라 포인터가 분산이 되어
데이터가 저장이되기 때문에, 포인터를 통해서 접근을 한다 => 포인터를 통하여 다음 데이터의 위치를
가르키고 있기 때문에 삽입/삭제에 용이하다.
배열의 경우 연속된 메모리의 주소를 가지고있기때문에 추가적인 삽입삭제보다는 검색을 하는데 용이하고, 
리스트의 경우에는 포인터를 통해서 데이터의 위치를 접근하기 때문에 삽입/삭제에 용이하다.

---------------------------------------------------

## OOP(객체 지향 프로그래밍)의 원칙

1) 추상화
객체의 공통적인 특징을 파악해 하나의 개념(클래스)으로 다루는 것.
2) 상속(일반화)
상위 개념을 하위 개념이 물려받아 재사용성을 높인다.
3) 다형성
다양한 형태로 표현이 가능한 구조를 의미한다. 서로 다른 클래스의 객체가 같은 입력을 받았을 때 각자의 방식으로 동작하는 것.
4) 정보 은닉
캡슐화로 데이터와 데이터를 다루는 법을 묶고, 내부 정보를 밖에서 조회/변경할 수 없게 한다.

SOLID원칙

- 단일 책임 원칙 (Single Responsibility Principle)
모든 클래스는 각각 하나의 책임만 가져야 한다. 클래스는 그 책임을 완전히 캡슐화 해야 한다.

- 개방 - 폐쇄 원칙 (Open Closed Principle)
확장에는 열려 있고 수정에는 닫혀있는, 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계 가 되어야 한다는 원칙.

- 리스코프 치환 원칙 (Liskov Substitution Principle)
자식 클래스는 언제나 자신의 부모 클래스를 대체 할 수 있다는 원칙.
자식 클래스는 부모 클래스의 책임을 무시하거나 재정의 하지 않고 확장만 수행하도록 해야 LSP 를 만족한다.

- 인터페이스 분리 원칙 (Interface Segregation Principle)
한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
하나의 일반적인 인터페이스보다는 여러개의 구체적인 인터페이스가 낫다.

- 의존 역전 원칙 (Dependency Inversion Principle)
의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것.
말이 너무 추상적이라 정리하자면, 구체적인 클래스보다 인터페이스나 추상클래스와 관계를 맺으라는 것.

----------------------------

## GC에 대해서 설명
GC는 Garbage Collection으로, 힙 영역에서 메모리 부족 현상을 해결하기 위해 쓰이지 않는 객체를 해제하는 작업이다.
(1)사용하는 객체를 mark하고 (2) mark되지 않는 객체를 제거하고 (3) full GC의 경우 제거함으로써 생기는 hole을 압축(Compact)한다.
모든 종류의 GC에서 STW가 발생한다.

Miner GC : 사용되지 않는 객체는 제거되고, 살아남은 객체만 survivor 1, 2 영역으로 이동. 오래 살아남은 객체는 old 영역으로 이동한다.
Major GC(full GC) : 단편화를 줄이기 위해 hole을 모으는 과정에서 STW가 발생한다.

- STW란
GC을 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것.

stop-the-world가 발생하면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈춘다.

GC 작업을 완료한 이후에야 중단했던 작업을 다시 시작한다.


##  Objects의 기본 메소드
equals : 동등성 검사
hashcode : 해쉬벨류 생성
toString : 문자열로 만듬

## String, StringBuilder, StringBuffer의 차이
String으로 생성된 문자열은 변경할 수 없다(불변성)
StringBuilder와 StringBuffer는 char로 문자열을 쌓은 후, 필요할 때마다 toString으로 문자열 객체를 만든다().
StringBuilder는 동기화를 지원하지 않는다는 차이가 있다.

- String을 생성하는 두가지 방식

new 연산자를 이용한 방식
리터럴을 이용한 방식
Java의 Heap에는 String Pool 이라는 특별한 영역에서 String 객체들을 관리합니다. 이 String Pool의 실체는 HashMap입니다. 다음 코드와 같이 문자열 리터럴을 사용하여 String 객체를 생성하면 String Pool에 기존에 같은 값을 가지는 String 객체가 있는지 검사하고 있으면 그 객체의 참조값을, 없으면 String Pool에 새로 String 객체를 생성하고 그 참조값을 리턴합니다.

그러므로 아래와 같은 결과를 확인할 수 있습니다. new 를 통한 객체 생성시에는 string pool에 생성되지 않고 따로 생성됩니다.

## ‘==’와 equals의 차이

- 객체 주소값 비교 vs 객체 내부 값 비교

String a = "aaa";
String b = "aaa";
String c = new String("aaa");
String d = new String("aaa");

System.out.println(a==b); //true
System.out.println(a==c);//false
System.out.println(a==d);//false
System.out.println(c==d);//false
System.out.println(a.equals(b));//true
System.out.println(a.equals(c));//true
System.out.println(c.equals(d));//true
image

## 자바의 접근 제어자에 대해 설명
private : 외부에서 접근 불가
package private : 패키지 외부에서 접근 불가
protected : 하위 클래스에서만 접근 가능
public : 외부에서 접근 가능

## 오버라이딩과 오버로딩에 대해 설명

오버라이딩: 부모 클래스의 메소드를 자식 클래스에서 재정의 하는 것. 오버로딩: 클래스에서 같은 이름의 메소드를 다른 인자를 받게 하여 여러 개 정의할 수 있는 것.

##  Generic이란?
제네릭은 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능입니다.

즉, 클래스 내부에서 사용할 데이터 타입을 나중에 인스턴스를 생성할 때 확정하는 것을 제네릭이라 합니다.

제네릭의 장점은

컴파일 시 강한 타입 체크를 할 수 있다.
실행시 타입 에러가 나는 것보다 컴파일 시에 미리 타입을 강하게 체크해서 에러를 사전에 방지
타입 변환(casting)을 제거한다.
비제네릭 코드는 불필요하게 타입 변환을 하기 때문에 프로그램 성능에 악영향을 미친다.
와일드카드란,
제네릭 클래스의 객체를 메소드의 매개변수로 받을 때, 그 객체의 타입 변수를 제한하는 것을 말한다.

와일드 카드<?>의 제한 종류
<? extends T> 와일드 카드의 상한 제한(upper bound) - T와 그 자손들을 구현한 객체들만 매개변수로 가능
<? super T> 와일드 카드의 하한 제한(lower bound) -T와 그 조상들을 구현한 객체들만 매개변수로 가능
<?> 제한 없음


## 인터페이스와 추상클래스의 차이

인터페이스는 다중 확장 가능, 추상 클래스는 불가
인터페이스의 필드값는 static final이지만 추상클래스는 non-static, non-final 필드 가능

## 자바 멀티쓰레드에서 동기화 방법

1) syncronized 키워드 사용
메소드 정의부 옆이나, 블록을 만들어서 구현할 수 있다.
클래스 기반 lock이므로 한 클래스에 syncronized 키워드가 붙은 메소드가 여러개라면,
그중 한개라도 다른 스레드가 사용하고 있을 경우 나머지 메소드(syncronized가 붙은)도 실행할 수 없다.

2) lock object 구현
직접 lock 역할을 하는 object를 구현할 수 있다.

## 자바8 변경사항
람다 표현식 (Lambda expression): 함수형 프로그래밍이 가능하게 됨
스트림 API (Stream API): 데이터를 추상화하여 다룰 수 있게 됨
java.time 패키지: 더 직관적이고 개선된 Date, Time API를 제공
나즈혼 (Nashorn): 자바스크립트의 새로운 엔진을 도입

## static 이란?

메모리에 단 한번만 올라가는 데이터
메소드영역에 저장

## 동적바인딩이란

런타임에 객체에 들어갈값이 결정되는것

EX) interface객체가 존재할때 interface객체에 해당 객체를 상속받은 객체를 집어넣을시 interface객체를 호출할시 해당 상속받은 객체가 호출되게 된다.

## 업캐스팅

동적바인딩시 자신을 상속받은 객체가 바인딩되는것

## JVM이란?

Java Virtual Machine의 준말로 타언어가 운영체제 위에서 동작하는것과는 다르게 자바코드는 JVM위에서 동작한다.
JVM의 이런 특성덕분에 Java코드는 운영체제에 구속받지않고 JVM위에서 작동한다.
Javac 컴파일러를 통해서 .java -> .class 바이트코드로 바뀌고 해당 .class파일은 인터프리터를 통해서 기계어로 번역된다.
해당양이 많을시 작업효율을 위해서 JIT인터프리터를 통해서 컴파일작업이 진행된다.

## 직렬화 설명

객체를 컴퓨터가 알아볼수있는 바이트코드로 번역하는것

역직렬화 : 바이트코드를 객체로 변환하는것

## Dynamic typing과 Static Typing의 차이

## 자바의 final 키워드

final키워드를 통해서 객체를 상수화시켜 외부에서 변환시킬수없게한다.

이런 특성때문에 DI시 생성자주입을 권장한다.

## 제네릭 사용하는 이유

강력하게 입출력형식을 강제해서 오류를 방지할수있음

## 다형성 설명.



## Collection Framework



## 어노테이션이란?

