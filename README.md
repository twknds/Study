준비해야될 내용

## 스프링

스프링 : 자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크로서 엔터프라이즈급 애플리케이션을 개발하기 위한 모든 기능을 종합적으로 제공하는 경량화된 솔루션

IOC : Depengency Lookup 즉 의존성 탐색 알맞은 의존성을 탐색하는것 , Depengency Ingection 의존성 주입으로 구성되며 Inversion of Control 즉 제어의 역전이라는 의미다,객체의 생성부터 생명주기 관리까지 제어의 주도권이 개발자가 아닌 프레임워크가 쥐게 되면서 개발자는 비즈니스 로직에만 집중할수 있게 된다

PSA : 잘 만들어진 인터페이스를 말하는것으로 스프링의 잘만들어진 인터페이스들을 지칭하는 말이다.
예시로 플랫폼트랜잭션매니저가 존재한다. 플랫폼트랜잭션매니저 인터페이스를 상속받아서 jdbc, hibernate, jpa등등 많은 트랜잭션 매니저를 구현할수있다.
그과정에서 플랫폼트랜잭션매니저의 코드는 변경이없으며 , 또한 외부 api를 테스트하는 코드를 만들기 위해서는 해당 api객체를 생성하는 인터페이스를 정의한후 해당 인터페이스를 상속받은 서비스객체를 생성한후 실제 외부 static API를 사용하는곳에서 구현한 서비스를 주입받게 하면 된다.

AOP : 관점 지향 프로그래밍 , 공통적으로 사용되는 코드 즉 흩어진 관심사를 통일해서 모듈화해 비즈니스로직에서 분리해서 사용하는것. 즉 중복코드를 줄이고 비즈니스 로직에만 집중할수 있도록 하는것에 있다.

gc :

Strong 참조방식의 객체의경우 unreachable해지면 gc의 대상이된다, 아니라면 대상이 되지 않음

jdk 9 이후로는 g1 gc가 기본 mark-sweep and compact방식

old영역으로 넘어가는 객체의 수를 최대한 줄이는것이 관건

## jwt 

header,payload,tail로 구성된다 header는 토큰의 종류를 나타냄 payload는 정보 tail은 암호화

access token , refresh token은 서버단에 저장되는 암호화 데이터로 front단에서 구글 ouath api를 사용해 유저의 구글아이디가 유효할시 code를 발급받게 되고 해당 code를 server로 

회원가입 요청을 하게 되면 email과 nickname값을 user객체로 포장해서 저장한뒤 accessT, refreshT를 발급하고 해당 토큰을 front로 반환해준다.

로그인 요청시 api요청 code를 보내고 해당 code를 파싱해서 email값을 얻고 레포지토리에서 조회후 토큰들 반환

서비스 요청시마다 token유효를 체크하고(인터셉터로 가로챔) accessT ,refreshT 유효성 검증

accessT 유효하지않고 refreshT 유효하지 않을시 Exception

인터셉터에서 예외발생하지 않을시 Controller로 request들 도착

## 컨테이너

컨테이너는 어떤 환경에서나 실행하기 위해 필요한 모든 요소를 포함하는 소프트웨어 패키지

컨테이너는 애플리케이션을 실제 구동 환경으로부터 추상화할 수 있는 논리 패키징 메커니즘을 제공

- 컨테이너의 이점

책임 분리,워크로드 이동성,애플리케이션 격리

- 컨테이너 vs VM

컨테이너는 VM보다 훨씬 더 경량입니다.

컨테이너는 OS 수준에서 가상화되고 VM은 하드웨어 수준에서 가상화됩니다.

가상머신은 애플리케이션을 동작시키기 위해서 애플리케이션이 사용하는 리소스만 사용하는 것뿐만 아니라 운영체제가 동작하기 위한 리소스가 추가로 필요

(컨테이너는 OS 커널을 공유하며 VM에 필요한 것보다 훨씬 적은 메모리를 사용합니다)

컨테이너는 가상 머신과 마찬가지로 애플리케이션을 관련 라이브러리 및 종속 항목과 함께 패키지로 묶어 소프트웨어 서비스 구동을 위한 격리 환경을 마련

- 도커

이미지 : 실행할 애플리케이션과 라이브러리 및 환경을 하나의 패키지로 묶은 것

컨테이너 : 이미지를 실행한 컨테이너

레지스트리 : 이미지를 저장하고 공유할 수 있는 스토리지

도커 허브 등과 같은 공용 레지스트리와 개인 및 특정 시스템만 사용할 수 있는 사설 레지스트리를 직접 구축 가능

도커는 컨테이너를 주류 기술로 만든 최초의 컨테이너 플랫폼으로, 쿠버네티스에서 기본적으로 애플리케이션을 구동하기 위한 구성요소 중 하나

서버 운영 측면에서 배포와 운영에 도커를 꼭 써야만 하는 건 아닙니다.

하지만 수평적 확장의 자유로움, 서버의 견고함을 보장하면서 동적으로 바꿀 수 있는 유연함, 인수인계 시간 절약 등의 편리한 해결 방법을 제공하는 도커를 쓰지 않을 이유는 없습니다.

## jdbc

JDBC API는 관계형 데이터베이스에 연결하고 Java 프로그램에서 SQL 쿼리를 실행하는 데 사용

JDBC API는 Java 프로그램과 실제 JDBC 드라이버 간의 느슨한 연결을 허용하는 방식으로 작성되어 한 데이터베이스에서 다른 데이터베이스 서버로 쉽게 전환할 수 있습니다

JDBC-ODBC 브리지 드라이버: JDBC-ODBC 브리지 드라이버는 ODBC 드라이버를 사용하여 데이터베이스에 연결합니다. JDBC-ODBC 브리지 드라이버는 JDBC 메서드 호출을 ODBC 함수 호출로 변환합니다. 이것은 드라이버가 얇기 때문에 권장되지 않습니다. 사용하기 쉽고 모든 데이터베이스에 쉽게 연결할 수 있습니다.

네이티브 API 드라이버(일부 자바 드라이버): 네이티브 API 드라이버는 데이터베이스의 클라이언트 측 라이브러리를 사용합니다. 드라이버는 JDBC 메서드 호출을 데이터베이스 API의 기본 호출로 변환합니다. 완전히 Java로 작성되지 않았습니다. 성능은 JDBC-ODBC 브리지 드라이버보다 우수합니다. 그러나 기본 드라이버는 각 클라이언트 시스템에 설치해야 합니다.

네트워크 프로토콜 드라이버(전체 자바 드라이버): 네트워크 프로토콜 드라이버는 JDBC 호출을 벤더별 데이터베이스 프로토콜로 직간접적으로 변환하는 미들웨어(애플리케이션 서버)를 사용합니다. 전적으로 Java로 작성되었습니다. 감사, 로드 밸런싱, 로깅 등과 같은 많은 작업을 수행할 수 있는 애플리케이션 서버 때문에 클라이언트 측 라이브러리에 대한 요구 사항이 없습니다.

씬 드라이버(전체 자바 드라이버): 씬 드라이버는 JDBC 호출을 공급업체별 데이터베이스 프로토콜로 직접 변환합니다. 그래서 얇은 드라이버로 알려져 있습니다. 전적으로 Java 언어로 작성되었습니다. 성능은 다른 모든 드라이버보다 우수하지만 이러한 드라이버는 데이터베이스에 따라 다릅니다.

## apache tomcat

웹 서버(apache) : 아파치서버란 클라이언트에서 요청하는 HTTP요청을 처리하는 웹서버를 의미한다,

이는 정적타입(HTML, CSS, 이미지 등)의 데이터만을 처리하기 때문에 톰캣이란 것이 등장한 것 같다

톰캣 : 톰캣 또한 아파치 소프트웨어 재단에서 후원을 하고 있으며, 오픈소스로 개발이 되고 있다.

JAVA EE 기반으로 만들어졌으며, JSP와 Servlet을 구동하기 위한 서블릿 컨테이너 역할을 수행한다.

아파치서버와는 다르게 DB연결, 다른 응용프로그램과 상호 작용 등 동적인 기능들을 사용할 수 있다.

서블릿 : 클라이언트의 요청을 받고 요청을 처리하여 결과를 클라이언트에게 제공하는 자바 인터페이스.

java.servlet.package에 정의된 인터페이스로서 서블릿의 라이프 사이클을 위한 세 가지 필수적인 메소드들을 정의한다. init(), service(), destory()

서블릿 컨테이너(servlet container) : 서블릿들을 모아 관리 , 새로운 요청이 들어올 때마다 새로운 스레드를 생성 , 작업이 끝난 서블릿 스레드 자동 제거

WAS(wab application server) : DB 처리, 로직 처리를 요구하는 동적타입을 제공하는 소프트웨어 프레임워크를 의미한다.

기본적으로 사용되는 기능 3가지는 아래와 같다.

- 프로그램 실행 환경과 데이터베이스 접속 기능을 제공한다.
- 여러 개의 트랜잭션을 관리한다.
- 업무를 처리하는 비즈니스 로직을 수행한다.

아파치 톰캣으로 부르는 이유? 기본적으로 위처럼 아파치와 톰캣의 기능은 나뉘어져 있지만, 톰캣 안에 있는 컨테이너를 통해 일부 아파치의 기능을 발휘하기 때문에 보통 아파치 톰캣으로 합쳐서 부르곤 한다.


## nginx 



## 무중단배포 



## jenkins 



## aws 



## n+1문제



## jsp

jsp의 httpservletrequest객체에다가 특정 servlet_id를 통해서 조회하는것이 아닌  해당 객체에서 계속 값을 넣었다 뺏다 하는방식으로 진행했음(트랜잭션처리가 없는 로컬 애플리케이션으로 설계했기때문)

## junit 

Exception관리 - checked, unchecked 두개의 차이는 컴파일과정에서 컴파일러가 체크하냐 안하냐의 차이이며, unchecked는 runtimeException을 상속받는다.

스프링 공식문서에는 checked는 트랜잭션 rollback이없고 unchecked는 롤백이있다고 되어있는데, 사실 이거는 개발자가 조정할수있는 부분이고 , 애플리케이션마다 다른부분이라 한마디로 속단할수없음.


## reflection

## java8 

## java11

## DB

- 정규화

- 인덱스

- 격리레벨
