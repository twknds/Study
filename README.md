## 데이터베이스의  특징


- 데이터의 독립성

물리적 독립성 : 데이터 베이스 사이즈를 늘리거나 줄일 때 관련된 응용 프로그램을 수정할 필요가 없다.

논리적 독립성 : 논리적인 구조를 가지므로 응용 프로그램의 요구를 만족시킬 수 있다.

- 데이터의 무결성

여러 경로를 통해 잘못된 데이터가 발생하는 경우를 방지하는 기능(데이터의 유효성 검사)

- 데이터의 보안성

권한이 있는 사용자들만 자원에 접근할 수 있도록 설정

- 데이터의 일관성

연관된 정보를 논리적인 구조로 관리함(어떤 데이터를 변경했을 때 나머지 데이터와 일치하지 않는 불일치성을 배제함)

데이터 중복 최소화, 데이터를 통합 관리함으로써 자료의 중복과 데이터의 중복 문제를 해결할 수 있다.


**  디스크 I/O를 줄일 수록 데이터 베이스의 성능은 좋아진다.

## 인덱스란?

인덱스는 말 그대로 색인이다. 예를 들어 설명하면 데이터는 책의 내용이고 데이터가 저장된 레코드 주소는 인덱스 목록에 있는 페이지 번호이다.

데이터 베이스도 마찬가지로 모든 데이터를 검색해서 찾으면 시간이 오래 걸리니까 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어둔다.

DBMS(데이터 베이스 관리 시스템)은 항상 정렬된 상태를 유지한다. (즉, 탐색하는데는 빠르지만 값을 추가, 삭제, 수정하는 경우에는 느리다.)

## 인덱스의 자료구조

B-Tree

일반적으로 사용되는 알고리즘으로 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱한다.

삽입시 트리 노드 분할과정에서 오버헤드가 많이발생한다.

Hash

컬럼의 값으로 해시 값을 계산해서 인덱스하는 알고리즘으로 매우 빠른 검색속도를 가지고 있다. 하지만 값을 변형해서 인덱싱하므로 값의 일부만으로 검색 할 때는 hash를 사용할 수 없다.

** B-tree보다 Hash가 효율적일 것 같지만 SELECT 질의의 조건에 부등호(<>)도 포함되므로 hash에서 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다.

** B-Tree의 경우 최악의 경우 O(logn) 이지만 Hash의경우 최악의경우 O(1)가 된다.

B+Tree

leaf node가 아닌 자료는 인덱스 노드라고 부르고, leaf node 자료는 데이터 노드라고 부릅니다.

인덱스 노드의 Value값에는 다음 노드를 가리킬 수 있는 포인터 주소가 존재합니다.

데이터 노드의 Value값에 데이터가 존재하는 것이죠.

따라서 키값은 중복될 수 있고 (인덱스 노드와 데이터 노드에서 동시에 등장 가능!!!), 데이터 검색을 위해서는 반드시 leaf node까지 내려가야 한다는 특징을 가지고 있습니다.

오늘날 데이터베이스에서 가장 중요한 것은 검색속도이기 때문에 대부분의 데이터베이스 시스템은 B+Tree구조를 채택하고 있습니다.

## 인덱스의 종류

- 클러스터링 인덱스(PK로 만든 인덱스)

- 논 클러스터링 인덱스(클러스터링 인덱스의 위치를 저장한 인덱스)

## 성능과 고려해야할 사항

인덱스를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가된다.

INSERT는 인덱스에 대한 데이터를 추가해야하고 DELETE는 인덱스에 존재하는 값은 삭제하지 않고 사용하지 않는다는 표시로 남게 된다. 따라서 row의 수는 그대로이므로 실제 데이터에 비해 허

수 데이터가 많이 존재할 수 있다.

정규화

## 정규화란?

관계형 데이터 베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업이다. 구체적으로 말하면 어떠한 함수적 종속성을 만족하는지에 따라 정규형이 정의되고 그 정규형을 만족하지 못하

는 릴레이션을 나누어서 만족하는 릴레이션으로 분해하는 작업이다.

함수적 종속성 : 속성들 간의 상호 관계로부터 유도되는 제약조건의 일종(X의 값이 Y의 값을 유일하게 결정하면 X는 Y를 함수적으로 결정한다.)

정규형의 조건

분해의 대상인 분해 집합은 무손실 조인을 보장해야 한다.

분해 집합은 함수적 종속성을 보존해야 한다.

## 정규화의 종류

- 제 1 정규형

속성의 도메인이 오직 원자 값(하나의 값)만을 포함하고, 튜플의 모든 속성이 도메인에 속하는 하나의 값을 가진다.

- 제 2 정규형

제 1 정규형에 속하면서 모든 비주요 속성들이 주요 속성에 대해서 완전 함수적 종속이면 만족한다.(완전 함수적 종속 : x -> y 라고 할 때, x의 어떠한 속성이라도 제거하면 더 이상 함수적 종

속성을 만족하지 않는 경우. 즉, 키가 아닌 열들이 각각 후보키에 대해 결정되는 릴레이션 형태)

- 제 3 정규형

제 2 정규형에 속하면서 어떠한 비주요 속성도 기본키에 대해서 이행적으로 종속되지 않으면 만족한다.(이행 함수적 종속 : x -> y , y -> z 의 경우에 x -> z를 추론할 수 있는 관계. 즉, 비

주요 속성이 비주요 속성에 의해 종속되는 경우가 없는 릴레이션 형태)

- BCNF 정규형

제 3 정규형에 속하면서 3 정규형을 보완하는 정규형으로, 후보키가 여러 개인 경우 제 3 정규형을 만족시키지만 이상 현상이 발생하는 경우가 있다.

모든 결정자(주요속성??)가 후보키 집합에 속하면 만족한다.

- 정규화의 장점

데이터 베이스 변경 시 발생하는 이상 현상들을 해결할 수 있다.

- 이상 현상

삽입 이상 : 원하지 않는 자료가 삽입, 삽입하는데 자료가 부족해 삽입x

삭제 이상 : 하나의 자료만 삭제했을 때 그 자료가 포함된 튜플 전체가 삭제됨(원하지 않는 정보 손실)

갱신 이상 : 정확하지 않거나 일부의 튜플만 갱신되어 정보가 일관성이 없어짐

연동된 응용 프로그램에 최소한의 영향만 미치게 만들어 응용 프로그램의 수명을 연장시킨다.

- 단점

릴레이션 간의 연산(JOIN 연산)이 많아진다. 이로 인해서 응답 시간이 느려질 수 있다.(빨라질 수도, 느려질 수도 있음)

- 대응책 : 반정규화

정규화된 속성, 관계를 시스템의 성능 향상 및 개발과 단순화를 위해 통합, 분리하는 기법이다.

성능이 저하될 것이 예상되는 경우 반정규화를 수행한다.(but, 과도하게 사용하면 데이터의 무결성이 깨질 수 있다. 또한 응답 시간이 늦어진다.)


## 트랜잭션

- 트랜잭션이란?

작업의 완전성을 보장해주는 것으로 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 

기능이다.

- 사용자의 입장에서는 작업의 논리적 단위로 이해할 수 있고 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.

## 트랜잭션과 Lock

이 둘은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다.

Lock : 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할

트랜잭션 : 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것

- 트랜잭션의 특성

트랜잭션은 ACID라는 4가지 특성을 만족해야 한다.

원자성(Atomicity) : 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어

야 한다.

일관성(Consistenct) : 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

고립성(Isolation) : 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

지속성(Durability) : 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터 베이스에 작업의 결과가 저장되어야 한다.

- Active

트랜잭션의 활동 상태

트래잭션이 실행중이며 동작중인 상태를 말한다.

- Failed

트랜잭션 실패 상태

트랜잭션이 더 이상 정상적으로 진행 할 수 없는 상태를 말한다.

- Partially Committed

트랜잭션의 Commit 명령이 도착한 상태

트랜잭션이 commit 이전 sql문이 수행되고 commit만 남은 상태를 말한다.

- Committed

트랜잭션 완료 상태

트랜잭션이 정상적으로 완료된 상태를 말한다.

- Aborted

트랙잭션 취소 상태

트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말한다.

** Partially Committed와 Committed의 차이점

Commit 요청이 들어오면 상태는 Partial Committed상태가 된다. 이후 Commit을 문제없이 수행할 수 있으면 Committed상태로 전이되고, 만약 오류가 발생하면 Failed상태가 된다.

즉, Partial Committed는 Commit요청이 들어왔을 때를 뜻하고

Committed는 Commit을 정상적으로 완료한 상태를 뜻한다.

** 트랜잭션을 사용할 때 주의할 점

꼭 필요한 최소의 코드에만 적용하는 것이 좋다.(트랜잭션의 범위를 최소화)

그 이유는 데이터 베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그렇게 되면 각 프로

그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있다.

## 교착상태

- 교착상태란(deadlock)?

두 개 이상의 트랜잭션이 특정 자원의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데 이를 뜻한다.

갱신연산(Insert, Update, Delete)를 실행하면 잠금을 획득한다.

** 교착상태의 빈도를 낮추는 방법

트랜잭션을 자주 커밋한다.

정해진 순서대로 테이블에 접근한다.

읽기 잠금 획득(SELECT ~ FOR UPDATE)의 사용을 피한다.

테이블 단위의 잠금을 획득해 갱신을 직렬화 하면 동시성은 떨어지지만 교착상태를 피할 수 있다.

** 교착상태 방지 프로토콜

타임아웃 기반 알고리즘

트랜잭션 Ti 실행 시, 타임아웃 기간(timeout interval)을 설정

Ti사 lock 획득을 위해 대기할 경우, 타임아웃 기간 동안만 대기

타임아웃 기간이 지나면 Ti를 철회하고 롤백

- 장점

알고리즘이 간단하다.

일정 시간 후 교착상태를 일으키는 트랜잭션이 무조건 취소되므로 교착상태가 해결된다.

- 단점

최적의 타임아웃 기간을 설정하는 것이 어렵다.

기아 현상이 자주 발생한다.

기아(starvation) : 동일한 트랜잭션이 계속 롤백되는 현상

- 타임스탬프(TimeStamp) TS를 이용하는 방법

먼저 시작한 트랜잭션이 어떤 것인지에 따라 대기하거나 롤백시킨다.

기아를 방지하기 위해서 재시작되는 트랜잭션의 시작 타임스탬프는 오리지널 타임스탬프를 사용

Ti의 오리지널 시작 타임스탬프를 TS(Ti)라고 할 때, Ti가 재시작되면 시작 타임스탬프를 TS(Ti)로 부여하는 방식

- Wait-Die 방식


다른 트랜잭션이 데이터를 점유하고 있을 때 기다리거나(Wait) 포기(Die)하는 방식이다.

트랜잭션 Ti가 Tj에 의해 로킹된 데이터를 요청할 때

Ti가 먼저 들어온 트랜잭션이라면 대기(Wait)

Ti가 나중에 들어온 트랜잭션이라면 포기(Die)하고, 나중에 재시작하여 다시 요청

재시작 될 때, Ti의 시작 타임스탬프는 오리지널 시작 타임스탬프 값인 TS(Ti)로 부여한다.


- Wound-Wait 방식

다른 트랜잭션이 데이터를 점유하고 있을 때, 빼앗거나(Wound) 기다리는(Wait) 방식이다.

트랜잭션 Ti가 Tj에 의해 로킹된 데이터를 요청할 때

Ti가 먼저 들어온 트랜잭션이라면 데이터를 선점(Wound)

Tj는 철회시키고, 나중에 재시작

재시작 될 때, Ti의 시작 타임스탬프는 오리지널 시작 타임스탬프 값인 TS(Ti)로 부여한다.

Ti가 나중에 들어온 트랜잭션이라면 대기(Wait)

** Wound-Wait 방식이 Wait-Die 방식에 비해 일반적으로 roll-back 횟수가 적다.



- 교착상태 탐지 프로토콜

대기 그래프를 작성하여 교착 발생 여부를 확인한다.

그래프를 그렸을 때, 순환구조(cycle)이 생성되면 교착상태가 발생하는 것

** 해결방안

희생할 트랜잭션 선정(victim) : 진행률, 시작시간, 연산량 등을 고려하여 최소비용 트랜잭션을 선정한다.

희생할 트랜잭션을 완전하게 롤백 : 이 때, 기아가 발생할 수 있다.

기아 발생을 줄이기 위해, 롤백 횟수를 기록하여 희생 트랜잭션 선정시 비용 계산에 포함시킨다.


## NoSQL

NoSQL의 출현에는 지난 20년간, 데이터를 저장하는 데에는 관계형 데이터베이스가 사용되었다. 트랜잭션을 통한 안정적인 데이터 관리가 가장 중요한 이슈였기 때문이다. 하지만 웹 2.0 환경과 빅데이터가 등장하면서 RDBMS는 난관에 부딪히게 되었는데, 바로 ‘데이터를 처리하는 데 필요한 비용의 증가’때문이다. 데이터와 트래픽의 양이 기하급수적으로 증가함에 따라 한 대에서 실행되도록 설계된 관계형 데이터베이스를 사용하는 것은 하드웨어적으로 큰 비용이 들게 되었다. 장비의 성능이 좋을수록, 성능을 향상시키는 데(Scale-up : 수직적 확장) 비용이 기하급수적으로 증가하기 때문이다.

NoSQL은 데이터의 일관성을 약간 포기한 대신 여러 대의 컴퓨터에 데이터를 분산하여 저장하는 것(Scale-out : 수평적 확장)을 목표로 등장하였다. NoSQL의 등장으로 작고 값싼 장비 여러 대로 대량의 데이터와 컴퓨팅 부하를 처리하는 것이 가능하게 되었다.

NoSQL에 트랜잭션이 없는이유는 NoSQL의 기본적인 존재이유 자체가 수평적 확장(데이터의 저장, 데이터의 )에 의의를 두고 어느정도의 데이터의 정합성과 무결성을 포기한것이기 때문에 트랜잭션이 존재하지 않는다.(존재할시 성능상의 오버헤드가 존재하기 때문에)

- NoSQL의 종류

NoSQL 데이터베이스는 크게 네 가지 모델로 나눌 수 있다.

- Key-value

키 값(Key-value) 저장소는 가장 단순한 형태의 NoSQL으로, 수평적 확장이 용이하다. 또한 아주 간단한 API만을 제공하기 때문에 배우는 것이 어렵지 않다.[4] 하지만 값의 내용을 사용한 쿼리가 불가능하다는 단점이 있다. 사용자는 키를 사용해 값을 읽어들인 뒤, 어플리케이션 레벨에서 적절히 처리해야 한다.

키-값 저장소는 데이터가 키와 값의 쌍으로 저장된다. 키는 값에 접근하기 위한 용도로 사용되며, 값은 어떠한 형태의 데이터라도 담을 수 있다. 심지어는 이미지나 비디오도 가능하다. 또한 간단한 API를 제공하는 만큼 질의의 속도가 굉장히 빠른 편이다.

Key-value 모델을 사용하는 NoSQL 데이터베이스로는 Memcached, Riak, Redis, Amazon Dynamo DB, LevelDB 등이 있다.


- Document

키-값 모델에서 한층 진화한 모델로 생각할 수 있다. 데이터는 키와 도큐먼트(Document)의 형태로 저장된다. 키-값 모델과 다른 점이라면 Value가 계층적인 형태인 도큐먼트로 저장된다는 것이다. 객체지향에서의 객체와 유사하며, 이들은 하나의 단위로 취급되어 저장된다. 다시 말해 하나의 객체를 여러 개의 테이블에 나눠 저장할 필요가 없어진다는 뜻이다. 또한 Document 모델에서는 도큐먼트 내의 item을 이용한 쿼리가 가능하다. 다만 이를 위해서는 Xquery나 다른 도큐먼트 질의 언어가 필요하다.

주요한 특징으로는 객체-관계 매핑이 필요하지 않다. 객체를 도큐먼트의 형태로 바로 저장 가능하기 때문이다. 또한 검색에 최적화되어 있는데, 이는 키-값 모델의 특징과 동일하다. 단점이라면 사용이 번거롭고 쿼리가 SQL과는 다르다는 점이다. 도큐먼트 모델에서는 질의의 결과가 JSON이나 xml 형태로 출력되기 때문에 그 사용 방법이 RDBMS에서의 질의 결과를 사용하는 방법과 다르다. 또한 질의 언어가 SQL과 다르기 때문에 사용에 익숙해지기까지 다소 어려움이 있을 수 있다.

Document 모델을 사용하는 NoSQL 데이터베이스로는 MongoDB, CouchDB, MarkLogic 등이 있다.

- Column-family

컬럼-패밀리(Column-family) 모델은 위의 두 모델[5]과는 다소 차이가 있지만 집합-지향 모델로 간주된다. 이전의 모델들이 키-값 쌍 중 값을 이용해 필드를 결정했다면, 특이하게도 이 모델은 키에서 필드를 결정한다. 키는 Row(키 값)와 Column-family, Column-name을 가진다. 연관된 데이터들은 같은 Column-family 안에 속해 있으며, 각자의 Column-name을 가진다. 관계형 모델로 설명하자면 어트리뷰트가 계층적인 구조를 가지고 있는 셈이다. 이렇게 저장된 데이터는 하나의 커다란 테이블로 표현이 가능하며, 질의는 Row, Column-family, Column-name을 통해 수행된다.

이러한 특징 덕에 컬럼-패밀리 모델은 클러스터링이 쉽게 이뤄지며, Time stamp가 존재해 값이 수정된 히스토리를 알 수 있다. 또한 값들은 일련의 바이너리 데이터로 존재하기 때문에 어떤 형태의 데이터라도 저장될 수 있다.

다만 위의 두 모델들과는 다르게 Blob 단위의 쿼리가 불가능하며, Row와 Column의 초기 디자인이 중요하다. Schema-less이긴 하지만 새로운 필드를 만드는 데 드는 비용이 크기 때문에 사실상 결정된 스키마를 변경하는 것이 어렵다.

Column-family 모델을 사용하는 NoSQL 데이터베이스로는 HBase, Cassandra, Hypertable 등이 있다.



- Graph

그래프(Graph) 모델은 상당히 독특한 디자인을 가진 모델로써 집합 지향 모델보다는 관계형 모델에 가깝다. 실제 세계의 데이타를 관계와 함께 표현하기 위해 디자인된 모델로써, 데이터는 연속적인 노드, 관계, 특성의 형태로 저장된다. 다시 말해 그래프 형태로 저장된다는 뜻이다. 따라서 그래프 모델에서의 질의는 그래프 순회를 통해 이루어진다.

개체와 관계를 그래프 형태로 표현한 것이므로 관계형 모델이라고 할 수 있으며, 데이터 간의 관계가 탐색의 키일 경우에 적합하다. 페이스북이나 트위터 같은 소셜 네트워크에서(내 친구의 친구를 찾는 질의 등) 적합하고, 연관된 데이터를 추천해주는 추천 엔진이나 패턴 인식 등의 데이터베이스로도 적합하다. 또한 집합 지향 모델과는 다르게 개체의 ACID 트랜잭션을 지원한다.

다만 그래프 모델은 클러스터링에는 적합하지 않다. 또한 질의 언어도 특화되어 있어 배우기 어렵다.

- NoSQL이 각광받는 이유

대부분의 사람들은 NoSQL이 RDBMS를 대체할 수 있을 것이라고는 생각하지 않는다. 그러기에는 RDBMS가 가진 장점이 너무나 명확하고, 또한 많은 사람들이 RDBMS을 사용하는 데 익숙해져 있기 때문이다. 그럼에도 불구하고 NoSQL이 각광받고 있는 까닭은 NoSQL만의 장점이 뚜렷하기 때문이다.

예를 들어 구매 내역이나 게임의 로그 같은 데이터들은 매 초마다 엄청난 양이 생성되지만 한번 저장되고 난 뒤에는 수정될 일이 거의 없다. 이런 데이터들을 저장하는 데 데이터의 일관성을 보장하기 위해 ACID 트랜잭션을 지원할 필요는 없을 것이다. 거기다 생성되는 데이터의 양도 많기 때문에 장비의 성능에도 상당한 영향을 미칠 것이다. NoSQL은 이러한 데이터들을 효율적으로 저장할 수 있다. 여러 대의 장비에 빠른 속도로 저장이 가능하며, 데이터의 양이 누적되더라도 얼마든지 수평적 확장이 가능하기 때문이다.

실제로 페이스북이나 트위터 같은 소셜 네트워크 서비스에서는 게시글들을 저장하는 데 NoSQL 데이터베이스를 사용하고 있다.[6] 매 초에 수백 기가~수 테라 바이트씩 생성되는 데이터들을 RDBMS를 사용해 저장한다면, 글 작성 버튼을 누른 후 글이 중앙 데이터베이스에 저장되기까지 한참을 기다려야 글을 성공적으로 게시할 수 있을 것이다. 하지만 NoSQL의 분산 데이터베이스를 사용한다면 부하가 분산되기 때문에 우리가 글쓰기 버튼을 누르고 한참을 기다릴 필요가 없게 된다. 또한 각종 검색 엔진에도 사용되는 것이 NoSQL인데, 웹 페이지 내의 텍스트들을 형태소 단위의 토큰으로 분리하여 토큰과 해당 토큰이 포함된 페이지들의 URL을 맵핑하는 Inverted Index(역 인덱스) 구조를 NoSQL을 통해 구현한다. 이런 기능을 일반적인 RDMBS로 구현했을 경우 검색 창에 단어를 입력했을 때마다 상당한 시간이 소요될 것이다.

하지만 데이터의 일관성이 보장되어야 하거나 여러번의 조인 연산이 필요한 데이터라면 NoSQL을 사용하는 것 보다 RDBMS를 사용하는 것이 좋을 것이다. NoSQL은 RDBMS를 대체하기 위한 데이터베이스가 아니라 상호 보완할 수 있는 데이터베이스이며, 따라서 목적에 맞게 사용하는 것이 중요하다.

C++, Java, Python 등 여러 언어를 사용해서 하나의 프로그램을 만들 수 있는 것처럼(Polyglot Programming) 데이터베이스 역시 다양한 저장소(Polyglot Persistance)를 사용할 수 있게 되었다는 점에서 NoSQL의 의의는 크다고 볼 수 있다.

- 사용할때 유의할 사항

NoSQL 데이터베이스의 공통적인 특징은 스키마 없이 동작한다는 점이다. 따라서 데이터 구조를 미리 정의할 필요가 없으며, 시간이 지나더라도 언제든지 바꿀 수 있기 때문에 비형식적인 데이터를 저장하는 데 용이하다. 하지만 이는 데이터베이스가 스키마를 직접 관리하지 않는 것을 의미할 뿐, 데이터 타입에 따른 암묵적인 스키마는 여전히 존재한다. 이 때문에 단일 값에 대한 데이터 타입에서 불일치가 발생할 수 있다.

예를 들어 필드의 이름을 “Quantity”라고 하기로 했다고 하자. 이것은 앞으로 저장할 때 반드시 필드의 이름을 “Quantity”라고 저장하겠다는 암묵적인 스키마가 된다. 암묵적인 스키마를 무시할 경우 Quantity를 quantity, qty, QUANTITY 등으로 저장할지도 모른다. 뜬금없이 qty, quantity같은 새로운 필드가 추가되는 것이나 마찬가지이다. 이는 NoSQL 데이터베이스가 암묵적인 스키마에 대해 전혀 알지 못하며, 이를 강제하지 않기 때문에 발생하는 일이다. 그렇게 때문에 NoSQL을 사용할 때에는 주의를 기울일 필요가 있다.

- NoSQL에서의 데이터 일치

RDBMS에서 관계형 튜플 안의 값은 단순해야 하며 중첩된 레코드나 리스트 등 다른 구조를 포함할 수 없는 반면, 메모리 내 데이터 구조에서는 이런 제약이 없어 훨씬 복잡한 구조를 사용한다. (ex : 리스트, 딕셔너리, 중첩된 객체 구조) 그 결과 복잡한 메모리 내 데이터 구조를 데이터베이스에 저장하려면 먼저 관계형 표현으로 변환해야 한다. 물론 이는 ORM(Objective-Relational Mapping : 객체-관계 매핑) 프레임워크를 통해 해결할 수 있지만, 여전히 관계형 모델과 메모리 내 데이터 구조 간에는 데이터 불일치는 존재한다. 이를 Impedance mismatch라 한다.

하지만 NoSQL은 그런 게 없다. 메모리 내의 데이터가 어떤 구조이든지 상관하지 않고 하나의 Aggregation으로 취급하여 저장해버리기 때문이다. 따라서 NoSQL에서는 ORM 프레임워크가 필요하지 않다.


- 집합-지향 모델

집합(Aggregate)이란 연산의 한 단위로 취급되는 연관된 객체들의 집합이다. 집합 지향 데이터베이스는 집합 자료구조로 이루어져 있다. 관계형 모델처럼 하나의 엔티티에 대한 ACID 트랜잭션[3]을 지원하지는 않지만, 하나의 집합에 대한 연산에서는 트랜잭션을 지원한다.

집합 지향 데이터베이스는 여러 대의 클러스터로 이루어진 시스템에서 사용하기 적합하다. 다시 말해 수평적 확장이 용이하다는 것이다. 이는 관계형 데이터베이스와는 달리 연관된 데이터들이 함께 움직이기 때문이다. 또한 메모리 내의 자료구조와 집합 간 데이터가 잘 일치하므로, 관계형 데이터베이스처럼 객체-관계 매핑 프레임워크가 필요하지 않다. 데이터의 검색도 아주 쉬운 편으로, 키나 ID를 사용하면 쉽게 집합 레코드를 찾아낼 수 있다.

집합 지향 데이터베이스는 조인 연산이 불가능한데, 이를 보완하기 위해 MongoDB나 Cassandra등의 데이터베이스에서는 맵 리듀스(MapReduce) 기능을 제공함으로써 조인과 유사한 연산을 가능하도록 설계했다. 이를 사용하여 데이터 분석도 가능하다. 하지만 사용법이 어렵고 Hadoop의 맵 리듀스에 비하면 속도도 매우 느리다.


## RDBMS에서의 성능향상

- 샤딩 

샤딩(Sharding)은 샤드 키(Shard key)를 기준으로 하나의 테이블을 수평 분할하여 서로 다른 클러스터에 분산 저장하고 질의할 수 있는 기법이다. 이를 통해 관계형 데이터베이스에서도 부하를 분산할 수 있지만 어플리케이션 레벨에서 모든 샤딩을 제어해야 한다. (어떤 데이터를 어느 클러스터에서 처리해야 하는지 등) 또한 여러 샤드에 걸치는 쿼리나 참조 정합성, 트랜잭션, 일관성의 제어에 문제가 발생한다.


