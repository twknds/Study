
**자바 언어의 장단점 및 특징**

< 장점 >

1. 운영체제에 독립적이다(운영체제로 부터 메모리를 할당받는 JVM위에서 동작한다)
2. 객체지향적 언어이다(유지 및 보수에 장점이 있다).
3. 자동으로 메모리 관리를 해준다(JVM GC의 장점이자 단점).
4. 동적로딩을 지원한다.
=> 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에만 클래스를
동적으로 로딩해서 생성을 한다( = 런타임에 객체를 로딩 = 런타임에 인스턴스 생성). 또한 유지보수시 해당 클래스만 수정하면 되기 때문에(결합도가 낮을경우 = 객체 지향의 원칙을 지킨경우) 전체 애플리케이션을 다시 컴파일할 필요가 없다. 따라서 유지보수가 빠르다(객체 지향 프로그래밍의 장점).
5. 무료 라이브러리가 많다.
 
< 단점 >

1. 타언어에 비해서 비교적 실행시간이 느리다.
2. 운영체제 뿐만 아니라 JVM에 대한 이해까지 필요하다.

< VS C언어 >
1. 사실 자바는 c와같은 정적언어이다.
2. c에 비해 자바가 메모리 낭비가 더 심함
---------------------------------------------------
**컬렉션이란 ?**

Collection이라는 것은 데이터의 연속된 집합, 그룹을 의미하고 Colleciton Framework는 여러
데이터들을 저장할 수 있는 자료구조를 클래스로 정의 해놓은 인터페이스 프레임워크를 의미합니다.
일단 Collection 인터페이스는 에는 Set, Map, List 인터페이스가 존재합니다.
그리고 무엇보다도 배열과의 차이점은 배열의 경우 정적으로 메모리를 할당하는 대신에 컬렉션의 경우
동적으로 메모리를 할당하게 됩니다. 리스트의 경우에는 메모리에 분산이 되어서 저장이됩니다 반대로
배열은 메모리에 연속적으로 저장이 됩니다 하지만 둘다 메모리는 힙영역에 저장이 된다.

1. Set
HashSet의 경우에는 저장순서를 예측할수없지만, TreeSet의 경우에는 정렬된 위치에 데이터를
저장합니다.
HashSet의 경우 해쉬함수를 이용해서 데이터를 참조하지만, TreeSet의경우에는 이진탐색을 통해서
데이터를 조회하게됩니다. 해싱이 이진탐색보다는 빠릅니다. TreeSet의 경우에는 이진탐색을 이용했기
때문에 정렬이 가능합니다.

HashSet값을 비교할때는 hashcode()를 통해 비교하며 두값의 hashcode()값이 equals == true 라면 같은값!

2. Map
Map 인터페이스의 경우에는 Key와 value로 구성이 되어있는 컬렉션인데요, 키의 중복은 허용되지만
value의 중복은 허용되지 않습니다

HashTable vs HashMap
1. HashTable의 경우 Null을 허용하지 않고, HashMap의 경우 Null을 허용한다 ! 
2. HashTable의 경우에는 동기화를 허용하며, HashMap은 안된다.
3. HashMap은 HashTable에 비해서 보조해시를 사용하기 때문에 해시충돌이 덜 발생한다. 비교적
저장을하는즉시 key값이나 value값에 따라서 정렬된 위치에 저장이된다

hash or tree
일반적으로 순서에 의존하지않고 value값을 조회하고 싶으면 hashSet을 사용하는게 맞습니다. 다만
iterator하게 value 값 전체를 처리해야한다면, treeSet을 사용하는게 좋습니다. 이는 O(logn)의 시간이
걸리게 됩니다.( 추가/ 제거 또한 마찬가지 O(logN)

List 인터페이스의 경우에는 앞서말씀드린 Set과 Map인터페이스와 달리 순서가 존재하며 데이터의
중복을 허용하는 컬렉션입니다.

ArrayList는 객체 자체를 저장하는것이아니고, 객체의 주소를 저장하는 것이다

LinkedList는 ArrayList와는 달리 인접된 객체를 링크해서 체인처럼 관리하기 때문에 조회를 하는데에는 시간이
오래걸립니다
다만 동일한 객체를 저장하게 되면 인덱스에는 객체가 저장되는게 아니고 객체의 주소가 저장이 되기때문에
동일한 주소가 저장이된다(ex) nonclustered index).

vector와 ArrayList의 차이점에 대해서는 Tread-Safe 의 유무인데 벡터의 경우에는 멀티스레드가
동시에 벡터에 접근을 할 수 없기때문에 안전하게 객체를 추가/ 수정이 가능하나, 동기화처리(Synchronized)를 하기 때문에
성능이 좋지는 않습니다.
=> vector 보다 copyonwriteArrayList()를 사용하는 게 좋다 ( 쓰기에만 lock()이 걸리고 읽기 동작은
lock 없이 사용이 가능하다 )

TMI) vertor를 상속받는 stack의 경우 FILO형식을 따르며 push를 통해서 위쪽에 데이터값을 쌓아올리는 방식인대, vector의 add public 메서드를 상속받아서 형식을 헤치게됌,
상속의 문제점을 보여주는 단편적인 예시이며 상속과 조합을 적절히 사용해야함을 알려줌!

LinkedList의 경우에는 ArrayList와는 달리, 값을 조회하는데는 최악의로는 O(N)의 시간이 발생하지만,
추가/삭제를 하는데에는 상수값의 시간으로 작업이 가능합니다. 반대로 ArrayList의 경우에는 데이터를
추가/삭제하는데 데이터의 위치를 전부 뒤로 당기거나 앞으로 밀리는 경우가 있기 때문에 최악의 경우
O(N) 시간이 발생하게 됩니다.

3. List와 Array의 차이점
배열은 메모리에 연속적으로 저장이되고, 리스트는 메모리에 연속적이 아니라 포인터가 분산이 되어
데이터가 저장이되기 때문에, 포인터를 통해서 접근을 한다 => 포인터를 통하여 다음 데이터의 위치를
가르키고 있기 때문에 삽입/삭제에 용이하다.
배열의 경우 연속된 메모리의 주소를 가지고있기때문에 추가적인 삽입삭제보다는 검색을 하는데 용이하고, 
리스트의 경우에는 포인터를 통해서 데이터의 위치를 접근하기 때문에 삽입/삭제에 용이하다.

---------------------------------------------------
=======
os

database

network
